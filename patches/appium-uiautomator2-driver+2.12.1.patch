diff --git a/node_modules/appium-uiautomator2-driver/build/lib/driver.js b/node_modules/appium-uiautomator2-driver/build/lib/driver.js
index e552a3f..7d704ec 100644
--- a/node_modules/appium-uiautomator2-driver/build/lib/driver.js
+++ b/node_modules/appium-uiautomator2-driver/build/lib/driver.js
@@ -1,53 +1,143 @@
-"use strict";
+'use strict';
 
-var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
-Object.defineProperty(exports, "__esModule", {
-  value: true
+var _interopRequireDefault = require('@babel/runtime/helpers/interopRequireDefault');
+Object.defineProperty(exports, '__esModule', {
+  value: true,
 });
 exports.default = exports.AndroidUiautomator2Driver = void 0;
-require("source-map-support/register");
-var _lodash = _interopRequireDefault(require("lodash"));
-var _driver = require("appium/driver");
-var _uiautomator = require("./uiautomator2");
-var _support = require("appium/support");
-var _asyncbox = require("asyncbox");
-var _bluebird = _interopRequireDefault(require("bluebird"));
-var _index = _interopRequireDefault(require("./commands/index"));
-var _appiumAdb = require("appium-adb");
-var _helpers = _interopRequireDefault(require("./helpers"));
-var _appiumAndroidDriver = require("appium-android-driver");
-var _desiredCaps = _interopRequireDefault(require("./desired-caps"));
-var _portscanner = require("portscanner");
-var _os = _interopRequireDefault(require("os"));
-var _path = _interopRequireDefault(require("path"));
-var _extensions = require("./extensions");
+require('source-map-support/register');
+var _lodash = _interopRequireDefault(require('lodash'));
+var _driver = require('appium/driver');
+var _uiautomator = require('./uiautomator2');
+var _support = require('appium/support');
+var _asyncbox = require('asyncbox');
+var _bluebird = _interopRequireDefault(require('bluebird'));
+var _index = _interopRequireDefault(require('./commands/index'));
+var _appiumAdb = require('appium-adb');
+var _helpers = _interopRequireDefault(require('./helpers'));
+var _appiumAndroidDriver = require('appium-android-driver');
+var _desiredCaps = _interopRequireDefault(require('./desired-caps'));
+var _portscanner = require('portscanner');
+var _os = _interopRequireDefault(require('os'));
+var _path = _interopRequireDefault(require('path'));
+var _extensions = require('./extensions');
 const helpers = Object.assign({}, _helpers.default, _appiumAndroidDriver.androidHelpers);
 const DEVICE_PORT_RANGE = [8200, 8299];
-const DEVICE_PORT_ALLOCATION_GUARD = _support.util.getLockFileGuard(_path.default.resolve(_os.default.tmpdir(), 'uia2_device_port_guard'), {
-  timeout: 25,
-  tryRecovery: true
-});
+const DEVICE_PORT_ALLOCATION_GUARD = _support.util.getLockFileGuard(
+  _path.default.resolve(_os.default.tmpdir(), 'uia2_device_port_guard'),
+  {
+    timeout: 25,
+    tryRecovery: true,
+  }
+);
 const DEVICE_PORT = 6790;
 const MJPEG_SERVER_DEVICE_PORT = 7810;
 const LOCALHOST_IP4 = '127.0.0.1';
-const NO_PROXY = [['GET', new RegExp('^/session/(?!.*/)')], ['GET', new RegExp('^/session/[^/]+/alert_[^/]+')], ['GET', new RegExp('^/session/[^/]+/alert/[^/]+')], ['GET', new RegExp('^/session/[^/]+/appium/[^/]+/current_activity')], ['GET', new RegExp('^/session/[^/]+/appium/[^/]+/current_package')], ['GET', new RegExp('^/session/[^/]+/appium/app/[^/]+')], ['GET', new RegExp('^/session/[^/]+/appium/device/[^/]+')], ['GET', new RegExp('^/session/[^/]+/appium/settings')], ['GET', new RegExp('^/session/[^/]+/context')], ['GET', new RegExp('^/session/[^/]+/contexts')], ['GET', new RegExp('^/session/[^/]+/element/[^/]+/attribute')], ['GET', new RegExp('^/session/[^/]+/element/[^/]+/displayed')], ['GET', new RegExp('^/session/[^/]+/element/[^/]+/enabled')], ['GET', new RegExp('^/session/[^/]+/element/[^/]+/location_in_view')], ['GET', new RegExp('^/session/[^/]+/element/[^/]+/name')], ['GET', new RegExp('^/session/[^/]+/element/[^/]+/screenshot')], ['GET', new RegExp('^/session/[^/]+/element/[^/]+/selected')], ['GET', new RegExp('^/session/[^/]+/ime/[^/]+')], ['GET', new RegExp('^/session/[^/]+/location')], ['GET', new RegExp('^/session/[^/]+/network_connection')], ['GET', new RegExp('^/session/[^/]+/screenshot')], ['GET', new RegExp('^/session/[^/]+/timeouts')], ['GET', new RegExp('^/session/[^/]+/url')], ['POST', new RegExp('^/session/[^/]+/[^/]+_alert$')], ['POST', new RegExp('^/session/[^/]+/actions')], ['POST', new RegExp('^/session/[^/]+/alert/[^/]+')], ['POST', new RegExp('^/session/[^/]+/app/[^/]')], ['POST', new RegExp('^/session/[^/]+/appium/[^/]+/start_activity')], ['POST', new RegExp('^/session/[^/]+/appium/app/[^/]+')], ['POST', new RegExp('^/session/[^/]+/appium/compare_images')], ['POST', new RegExp('^/session/[^/]+/appium/device/(?!set_clipboard)[^/]+')], ['POST', new RegExp('^/session/[^/]+/appium/element/[^/]+/replace_value')], ['POST', new RegExp('^/session/[^/]+/appium/element/[^/]+/value')], ['POST', new RegExp('^/session/[^/]+/appium/getPerformanceData')], ['POST', new RegExp('^/session/[^/]+/appium/performanceData/types')], ['POST', new RegExp('^/session/[^/]+/appium/settings')], ['POST', new RegExp('^/session/[^/]+/appium/execute_driver')], ['POST', new RegExp('^/session/[^/]+/appium/start_recording_screen')], ['POST', new RegExp('^/session/[^/]+/appium/stop_recording_screen')], ['POST', new RegExp('^/session/[^/]+/appium/.*event')], ['POST', new RegExp('^/session/[^/]+/context')], ['POST', new RegExp('^/session/[^/]+/element')], ['POST', new RegExp('^/session/[^/]+/ime/[^/]+')], ['POST', new RegExp('^/session/[^/]+/keys')], ['POST', new RegExp('^/session/[^/]+/location')], ['POST', new RegExp('^/session/[^/]+/network_connection')], ['POST', new RegExp('^/session/[^/]+/timeouts')], ['POST', new RegExp('^/session/[^/]+/touch/multi/perform')], ['POST', new RegExp('^/session/[^/]+/touch/perform')], ['POST', new RegExp('^/session/[^/]+/url')], ['GET', new RegExp('^/session/[^/]+/log/types')], ['POST', new RegExp('^/session/[^/]+/execute')], ['POST', new RegExp('^/session/[^/]+/execute_async')], ['POST', new RegExp('^/session/[^/]+/log')], ['GET', new RegExp('^/session/[^/]+/se/log/types')], ['GET', new RegExp('^/session/[^/]+/window/rect')], ['POST', new RegExp('^/session/[^/]+/execute/async')], ['POST', new RegExp('^/session/[^/]+/execute/sync')], ['POST', new RegExp('^/session/[^/]+/se/log')]];
-const CHROME_NO_PROXY = [['GET', new RegExp('^/session/[^/]+/appium')], ['GET', new RegExp('^/session/[^/]+/context')], ['GET', new RegExp('^/session/[^/]+/element/[^/]+/rect')], ['GET', new RegExp('^/session/[^/]+/orientation')], ['POST', new RegExp('^/session/[^/]+/appium')], ['POST', new RegExp('^/session/[^/]+/context')], ['POST', new RegExp('^/session/[^/]+/orientation')], ['POST', new RegExp('^/session/[^/]+/touch/multi/perform')], ['POST', new RegExp('^/session/[^/]+/touch/perform')], ['POST', new RegExp('^/session/[^/]+/execute$')], ['POST', new RegExp('^/session/[^/]+/execute/sync')], ['GET', new RegExp('^/session/[^/]+/log/types$')], ['POST', new RegExp('^/session/[^/]+/log$')], ['GET', new RegExp('^/session/[^/]+/se/log/types$')], ['POST', new RegExp('^/session/[^/]+/se/log$')]];
+const NO_PROXY = [
+  ['GET', new RegExp('^/session/(?!.*/)')],
+  ['GET', new RegExp('^/session/[^/]+/alert_[^/]+')],
+  ['GET', new RegExp('^/session/[^/]+/alert/[^/]+')],
+  ['GET', new RegExp('^/session/[^/]+/appium/[^/]+/current_activity')],
+  ['GET', new RegExp('^/session/[^/]+/appium/[^/]+/current_package')],
+  ['GET', new RegExp('^/session/[^/]+/appium/app/[^/]+')],
+  ['GET', new RegExp('^/session/[^/]+/appium/device/[^/]+')],
+  ['GET', new RegExp('^/session/[^/]+/appium/settings')],
+  ['GET', new RegExp('^/session/[^/]+/context')],
+  ['GET', new RegExp('^/session/[^/]+/contexts')],
+  ['GET', new RegExp('^/session/[^/]+/element/[^/]+/attribute')],
+  ['GET', new RegExp('^/session/[^/]+/element/[^/]+/displayed')],
+  ['GET', new RegExp('^/session/[^/]+/element/[^/]+/enabled')],
+  ['GET', new RegExp('^/session/[^/]+/element/[^/]+/location_in_view')],
+  ['GET', new RegExp('^/session/[^/]+/element/[^/]+/name')],
+  ['GET', new RegExp('^/session/[^/]+/element/[^/]+/screenshot')],
+  ['GET', new RegExp('^/session/[^/]+/element/[^/]+/selected')],
+  ['GET', new RegExp('^/session/[^/]+/ime/[^/]+')],
+  ['GET', new RegExp('^/session/[^/]+/location')],
+  ['GET', new RegExp('^/session/[^/]+/network_connection')],
+  ['GET', new RegExp('^/session/[^/]+/screenshot')],
+  ['GET', new RegExp('^/session/[^/]+/timeouts')],
+  ['GET', new RegExp('^/session/[^/]+/url')],
+  ['POST', new RegExp('^/session/[^/]+/[^/]+_alert$')],
+  ['POST', new RegExp('^/session/[^/]+/actions')],
+  ['POST', new RegExp('^/session/[^/]+/alert/[^/]+')],
+  ['POST', new RegExp('^/session/[^/]+/app/[^/]')],
+  ['POST', new RegExp('^/session/[^/]+/appium/[^/]+/start_activity')],
+  ['POST', new RegExp('^/session/[^/]+/appium/app/[^/]+')],
+  ['POST', new RegExp('^/session/[^/]+/appium/compare_images')],
+  ['POST', new RegExp('^/session/[^/]+/appium/device/(?!set_clipboard)[^/]+')],
+  ['POST', new RegExp('^/session/[^/]+/appium/element/[^/]+/replace_value')],
+  ['POST', new RegExp('^/session/[^/]+/appium/element/[^/]+/value')],
+  ['POST', new RegExp('^/session/[^/]+/appium/getPerformanceData')],
+  ['POST', new RegExp('^/session/[^/]+/appium/performanceData/types')],
+  ['POST', new RegExp('^/session/[^/]+/appium/settings')],
+  ['POST', new RegExp('^/session/[^/]+/appium/execute_driver')],
+  ['POST', new RegExp('^/session/[^/]+/appium/start_recording_screen')],
+  ['POST', new RegExp('^/session/[^/]+/appium/stop_recording_screen')],
+  ['POST', new RegExp('^/session/[^/]+/appium/.*event')],
+  ['POST', new RegExp('^/session/[^/]+/context')],
+  ['POST', new RegExp('^/session/[^/]+/element')],
+  ['POST', new RegExp('^/session/[^/]+/ime/[^/]+')],
+  ['POST', new RegExp('^/session/[^/]+/keys')],
+  ['POST', new RegExp('^/session/[^/]+/location')],
+  ['POST', new RegExp('^/session/[^/]+/network_connection')],
+  ['POST', new RegExp('^/session/[^/]+/timeouts')],
+  ['POST', new RegExp('^/session/[^/]+/touch/multi/perform')],
+  ['POST', new RegExp('^/session/[^/]+/touch/perform')],
+  ['POST', new RegExp('^/session/[^/]+/url')],
+  ['GET', new RegExp('^/session/[^/]+/log/types')],
+  ['POST', new RegExp('^/session/[^/]+/execute')],
+  ['POST', new RegExp('^/session/[^/]+/execute_async')],
+  ['POST', new RegExp('^/session/[^/]+/log')],
+  ['GET', new RegExp('^/session/[^/]+/se/log/types')],
+  ['GET', new RegExp('^/session/[^/]+/window/rect')],
+  ['POST', new RegExp('^/session/[^/]+/execute/async')],
+  ['POST', new RegExp('^/session/[^/]+/execute/sync')],
+  ['POST', new RegExp('^/session/[^/]+/se/log')],
+];
+const CHROME_NO_PROXY = [
+  ['GET', new RegExp('^/session/[^/]+/appium')],
+  ['GET', new RegExp('^/session/[^/]+/context')],
+  ['GET', new RegExp('^/session/[^/]+/element/[^/]+/rect')],
+  ['GET', new RegExp('^/session/[^/]+/orientation')],
+  ['POST', new RegExp('^/session/[^/]+/appium')],
+  ['POST', new RegExp('^/session/[^/]+/context')],
+  ['POST', new RegExp('^/session/[^/]+/orientation')],
+  ['POST', new RegExp('^/session/[^/]+/touch/multi/perform')],
+  ['POST', new RegExp('^/session/[^/]+/touch/perform')],
+  ['POST', new RegExp('^/session/[^/]+/execute$')],
+  ['POST', new RegExp('^/session/[^/]+/execute/sync')],
+  ['GET', new RegExp('^/session/[^/]+/log/types$')],
+  ['POST', new RegExp('^/session/[^/]+/log$')],
+  ['GET', new RegExp('^/session/[^/]+/se/log/types$')],
+  ['POST', new RegExp('^/session/[^/]+/se/log$')],
+];
 const MEMOIZED_FUNCTIONS = ['getStatusBarHeight', 'getDevicePixelRatio'];
 class AndroidUiautomator2Driver extends _driver.BaseDriver {
   constructor(opts = {}, shouldValidateCaps = true) {
     delete opts.shell;
     super(opts, shouldValidateCaps);
-    this.locatorStrategies = ['xpath', 'id', 'class name', 'accessibility id', 'css selector', '-android uiautomator'];
+    this.locatorStrategies = [
+      'xpath',
+      'id',
+      'class name',
+      'accessibility id',
+      'css selector',
+      '-android uiautomator',
+    ];
     this.desiredCapConstraints = _desiredCaps.default;
     this.uiautomator2 = null;
     this.jwpProxyActive = false;
     this.defaultIME = null;
     this.jwpProxyAvoid = NO_PROXY;
     this.apkStrings = {};
-    this.settings = new _driver.DeviceSettings({
-      ignoreUnimportantViews: false,
-      allowInvisibleElements: false
-    }, this.onSettingsUpdate.bind(this));
+    this.settings = new _driver.DeviceSettings(
+      {
+        ignoreUnimportantViews: false,
+        allowInvisibleElements: true,
+        enableMultiWindows: true,
+      },
+      this.onSettingsUpdate.bind(this)
+    );
     this.chromedriver = null;
     this.sessionChromedrivers = {};
     for (const fn of MEMOIZED_FUNCTIONS) {
@@ -55,7 +145,10 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
     }
   }
   validateDesiredCaps(caps) {
-    return super.validateDesiredCaps(caps) && _appiumAndroidDriver.androidHelpers.validateDesiredCaps(caps);
+    return (
+      super.validateDesiredCaps(caps) &&
+      _appiumAndroidDriver.androidHelpers.validateDesiredCaps(caps)
+    );
   }
   async createSession(...args) {
     try {
@@ -69,7 +162,7 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
         networkConnectionEnabled: true,
         locationContextEnabled: false,
         warnings: {},
-        desired: this.caps
+        desired: this.caps,
       };
       this.caps = Object.assign(serverDetails, this.caps);
       this.curContext = this.defaultContextName();
@@ -77,15 +170,12 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
         fullReset: false,
         autoLaunch: true,
         adbPort: _appiumAdb.DEFAULT_ADB_PORT,
-        androidInstallTimeout: 90000
+        androidInstallTimeout: 90000,
       };
       _lodash.default.defaults(this.opts, defaultOpts);
       if (this.isChromeSession) {
         this.log.info("We're going to run a Chrome-based session");
-        let {
-          pkg,
-          activity
-        } = helpers.getChromePkg(this.opts.browserName);
+        let {pkg, activity} = helpers.getChromePkg(this.opts.browserName);
         this.opts.appPackage = this.caps.appPackage = pkg;
         this.opts.appActivity = this.caps.appActivity = activity;
         this.log.info(`Chrome-type package and activity are ${pkg} and ${activity}`);
@@ -94,12 +184,18 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
         this.setAvdFromCapabilities(caps);
       }
       if (this.opts.app) {
-        this.opts.app = await this.helpers.configureApp(this.opts.app, [_extensions.APK_EXTENSION, _extensions.APKS_EXTENSION]);
+        this.opts.app = await this.helpers.configureApp(this.opts.app, [
+          _extensions.APK_EXTENSION,
+          _extensions.APKS_EXTENSION,
+        ]);
         await this.checkAppPresent();
       } else if (this.opts.appPackage) {
         this.log.info(`Starting '${this.opts.appPackage}' directly on the device`);
       } else {
-        this.log.info(`Neither 'app' nor 'appPackage' was set. Starting UiAutomator2 ` + 'without the target application');
+        this.log.info(
+          `Neither 'app' nor 'appPackage' was set. Starting UiAutomator2 ` +
+            'without the target application'
+        );
       }
       this.opts.adbPort = this.opts.adbPort || _appiumAdb.DEFAULT_ADB_PORT;
       await this.startUiAutomator2Session();
@@ -137,20 +233,31 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
       this.log.info('avd name defined, ignoring device name and platform version');
     } else {
       if (!caps.deviceName) {
-        this.log.errorAndThrow('avd or deviceName should be specified when reboot option is enables');
+        this.log.errorAndThrow(
+          'avd or deviceName should be specified when reboot option is enables'
+        );
       }
       if (!caps.platformVersion) {
-        this.log.errorAndThrow('avd or platformVersion should be specified when reboot option is enabled');
+        this.log.errorAndThrow(
+          'avd or platformVersion should be specified when reboot option is enabled'
+        );
       }
       let avdDevice = caps.deviceName.replace(/[^a-zA-Z0-9_.]/g, '-');
       this.opts.avd = `${avdDevice}__${caps.platformVersion}`;
     }
   }
   async allocateSystemPort() {
-    const forwardPort = async localPort => {
-      this.log.debug(`Forwarding UiAutomator2 Server port ${DEVICE_PORT} to local port ${localPort}`);
+    const forwardPort = async (localPort) => {
+      this.log.debug(
+        `Forwarding UiAutomator2 Server port ${DEVICE_PORT} to local port ${localPort}`
+      );
       if ((await (0, _portscanner.checkPortStatus)(localPort, LOCALHOST_IP4)) === 'open') {
-        this.log.errorAndThrow(`UiAutomator2 Server cannot start because the local port #${localPort} is busy. ` + `Make sure the port you provide via 'systemPort' capability is not occupied. ` + `This situation might often be a result of an inaccurate sessions management, e.g. ` + `old automation sessions on the same device must always be closed before starting new ones.`);
+        this.log.errorAndThrow(
+          `UiAutomator2 Server cannot start because the local port #${localPort} is busy. ` +
+            `Make sure the port you provide via 'systemPort' capability is not occupied. ` +
+            `This situation might often be a result of an inaccurate sessions management, e.g. ` +
+            `old automation sessions on the same device must always be closed before starting new ones.`
+        );
       }
       await this.adb.forwardPort(localPort, DEVICE_PORT);
     };
@@ -163,7 +270,12 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
       try {
         this.opts.systemPort = await (0, _portscanner.findAPortNotInUse)(startPort, endPort);
       } catch (e) {
-        this.log.errorAndThrow(`Cannot find any free port in range ${startPort}..${endPort}}. ` + `Please set the available port number by providing the systemPort capability or ` + `double check the processes that are locking ports within this range and terminate ` + `these which are not needed anymore`);
+        this.log.errorAndThrow(
+          `Cannot find any free port in range ${startPort}..${endPort}}. ` +
+            `Please set the available port number by providing the systemPort capability or ` +
+            `double check the processes that are locking ports within this range and terminate ` +
+            `these which are not needed anymore`
+        );
       }
       await forwardPort(this.opts.systemPort);
     });
@@ -175,7 +287,9 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
     if (this._hasSystemPortInCaps) {
       await this.adb.removePortForward(this.opts.systemPort);
     } else {
-      await DEVICE_PORT_ALLOCATION_GUARD(async () => await this.adb.removePortForward(this.opts.systemPort));
+      await DEVICE_PORT_ALLOCATION_GUARD(
+        async () => await this.adb.removePortForward(this.opts.systemPort)
+      );
     }
   }
   async allocateMjpegServerPort() {
@@ -189,16 +303,16 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
     }
   }
   async startUiAutomator2Session() {
-    let {
-      udid,
-      emPort
-    } = await helpers.getDeviceInfoFromCaps(this.opts);
+    let {udid, emPort} = await helpers.getDeviceInfoFromCaps(this.opts);
     this.opts.udid = udid;
     this.opts.emPort = emPort;
     this.adb = await _appiumAndroidDriver.androidHelpers.createADB(this.opts);
     const apiLevel = await this.adb.getApiLevel();
     if (apiLevel < 21) {
-      this.log.errorAndThrow('UIAutomator2 is only supported since Android 5.0 (Lollipop). ' + 'You could still use other supported backends in order to automate older Android versions.');
+      this.log.errorAndThrow(
+        'UIAutomator2 is only supported since Android 5.0 (Lollipop). ' +
+          'You could still use other supported backends in order to automate older Android versions.'
+      );
     }
     if (apiLevel >= 28) {
       this.log.info('Relaxing hidden api policy');
@@ -206,7 +320,9 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
     }
     if (_support.util.hasValue(this.opts.gpsEnabled)) {
       if (this.isEmulator()) {
-        this.log.info(`Trying to ${this.opts.gpsEnabled ? 'enable' : 'disable'} gps location provider`);
+        this.log.info(
+          `Trying to ${this.opts.gpsEnabled ? 'enable' : 'disable'} gps location provider`
+        );
         await this.adb.toggleGPSLocationProvider(this.opts.gpsEnabled);
       } else {
         this.log.warn(`Sorry! 'gpsEnabled' capability is only available for emulators`);
@@ -258,14 +374,8 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
     this.jwpProxyActive = true;
   }
   async addDeviceInfoToCaps() {
-    const {
-      apiVersion,
-      platformVersion,
-      manufacturer,
-      model,
-      realDisplaySize,
-      displayDensity
-    } = await this.mobileGetDeviceInfo();
+    const {apiVersion, platformVersion, manufacturer, model, realDisplaySize, displayDensity} =
+      await this.mobileGetDeviceInfo();
     this.caps.deviceApiLevel = parseInt(apiVersion, 10);
     this.caps.platformVersion = platformVersion;
     this.caps.deviceScreenSize = realDisplaySize;
@@ -285,7 +395,7 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
       appActivity: this.opts.appActivity,
       disableWindowAnimation: !!this.opts.disableWindowAnimation,
       disableSuppressAccessibilityService: this.opts.disableSuppressAccessibilityService,
-      readTimeout: this.opts.uiautomator2ServerReadTimeout
+      readTimeout: this.opts.uiautomator2ServerReadTimeout,
     };
     this.uiautomator2 = new _uiautomator.UiAutomator2Server(this.log, uiautomator2Opts);
     this.proxyReqRes = this.uiautomator2.proxyReqRes.bind(this.uiautomator2);
@@ -295,15 +405,30 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
     } else {
       await this.uiautomator2.installServerApk(this.opts.uiautomator2ServerInstallTimeout);
       try {
-        await this.adb.addToDeviceIdleWhitelist(_appiumAndroidDriver.SETTINGS_HELPER_PKG_ID, _uiautomator.SERVER_PACKAGE_ID, _uiautomator.SERVER_TEST_PACKAGE_ID);
+        await this.adb.addToDeviceIdleWhitelist(
+          _appiumAndroidDriver.SETTINGS_HELPER_PKG_ID,
+          _uiautomator.SERVER_PACKAGE_ID,
+          _uiautomator.SERVER_TEST_PACKAGE_ID
+        );
       } catch (e) {
-        this.log.warn(`Cannot add server packages to the Doze whitelist. Original error: ` + (e.stderr || e.message));
+        this.log.warn(
+          `Cannot add server packages to the Doze whitelist. Original error: ` +
+            (e.stderr || e.message)
+        );
       }
     }
   }
   async initAUT() {
     if (this.opts.uninstallOtherPackages) {
-      await helpers.uninstallOtherPackages(this.adb, helpers.parseArray(this.opts.uninstallOtherPackages), [_appiumAndroidDriver.SETTINGS_HELPER_PKG_ID, _uiautomator.SERVER_PACKAGE_ID, _uiautomator.SERVER_TEST_PACKAGE_ID]);
+      await helpers.uninstallOtherPackages(
+        this.adb,
+        helpers.parseArray(this.opts.uninstallOtherPackages),
+        [
+          _appiumAndroidDriver.SETTINGS_HELPER_PKG_ID,
+          _uiautomator.SERVER_PACKAGE_ID,
+          _uiautomator.SERVER_TEST_PACKAGE_ID,
+        ]
+      );
     }
     if (this.opts.otherApps) {
       let otherApps;
@@ -312,14 +437,24 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
       } catch (e) {
         this.log.errorAndThrow(`Could not parse "otherApps" capability: ${e.message}`);
       }
-      otherApps = await _bluebird.default.all(otherApps.map(app => this.helpers.configureApp(app, [_extensions.APK_EXTENSION, _extensions.APKS_EXTENSION])));
+      otherApps = await _bluebird.default.all(
+        otherApps.map((app) =>
+          this.helpers.configureApp(app, [_extensions.APK_EXTENSION, _extensions.APKS_EXTENSION])
+        )
+      );
       await helpers.installOtherApks(otherApps, this.adb, this.opts);
     }
     if (this.opts.app) {
-      if (this.opts.noReset && !(await this.adb.isAppInstalled(this.opts.appPackage)) || !this.opts.noReset) {
-        if (!this.opts.noSign && !(await this.adb.checkApkCert(this.opts.app, this.opts.appPackage, {
-          requireDefaultCert: false
-        }))) {
+      if (
+        (this.opts.noReset && !(await this.adb.isAppInstalled(this.opts.appPackage))) ||
+        !this.opts.noReset
+      ) {
+        if (
+          !this.opts.noSign &&
+          !(await this.adb.checkApkCert(this.opts.app, this.opts.appPackage, {
+            requireDefaultCert: false,
+          }))
+        ) {
           await helpers.signApp(this.adb, this.opts.app);
         }
         if (!this.opts.skipUninstall) {
@@ -327,11 +462,15 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
         }
         await helpers.installApk(this.adb, this.opts);
       } else {
-        this.log.debug('noReset has been requested and the app is already installed. Doing nothing');
+        this.log.debug(
+          'noReset has been requested and the app is already installed. Doing nothing'
+        );
       }
     } else {
       if (this.opts.fullReset) {
-        this.log.errorAndThrow('Full reset requires an app capability, use fastReset if app is not provided');
+        this.log.errorAndThrow(
+          'Full reset requires an app capability, use fastReset if app is not provided'
+        );
       }
       this.log.debug('No app capability. Assuming it is already on the device');
       if (this.opts.fastReset && this.opts.appPackage) {
@@ -342,14 +481,27 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
   async ensureAppStarts() {
     const appWaitPackage = this.opts.appWaitPackage || this.opts.appPackage;
     const appWaitActivity = this.opts.appWaitActivity || this.opts.appActivity;
-    this.log.info(`Starting '${this.opts.appPackage}/${this.opts.appActivity} ` + `and waiting for '${appWaitPackage}/${appWaitActivity}'`);
+    this.log.info(
+      `Starting '${this.opts.appPackage}/${this.opts.appActivity} ` +
+        `and waiting for '${appWaitPackage}/${appWaitActivity}'`
+    );
     if (this.caps.androidCoverage) {
-      this.log.info(`androidCoverage is configured. ` + ` Starting instrumentation of '${this.caps.androidCoverage}'...`);
+      this.log.info(
+        `androidCoverage is configured. ` +
+          ` Starting instrumentation of '${this.caps.androidCoverage}'...`
+      );
       await this.adb.androidCoverage(this.caps.androidCoverage, appWaitPackage, appWaitActivity);
       return;
     }
-    if (this.opts.noReset && !this.opts.forceAppLaunch && (await this.adb.processExists(this.opts.appPackage))) {
-      this.log.info(`'${this.opts.appPackage}' is already running and noReset is enabled. ` + `Set forceAppLaunch capability to true if the app must be forcefully restarted on session startup.`);
+    if (
+      this.opts.noReset &&
+      !this.opts.forceAppLaunch &&
+      (await this.adb.processExists(this.opts.appPackage))
+    ) {
+      this.log.info(
+        `'${this.opts.appPackage}' is already running and noReset is enabled. ` +
+          `Set forceAppLaunch capability to true if the app must be forcefully restarted on session startup.`
+      );
       return;
     }
     await this.adb.startApp({
@@ -365,25 +517,32 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
       optionalIntentArguments: this.opts.optionalIntentArguments,
       stopApp: this.opts.forceAppLaunch || !this.opts.dontStopAppOnReset,
       retry: true,
-      user: this.opts.userProfile
+      user: this.opts.userProfile,
     });
   }
   async deleteSession() {
     this.log.debug('Deleting UiAutomator2 session');
-    const screenRecordingStopTasks = [async () => {
-      if (!_lodash.default.isEmpty(this._screenRecordingProperties)) {
-        await this.stopRecordingScreen();
-      }
-    }, async () => {
-      if (await this.mobileIsMediaProjectionRecordingRunning()) {
-        await this.mobileStopMediaProjectionRecording();
-      }
-    }, async () => {
-      if (!_lodash.default.isEmpty(this._screenStreamingProps)) {
-        await this.mobileStopScreenStreaming();
-      }
-    }];
-    await _appiumAndroidDriver.androidHelpers.removeAllSessionWebSocketHandlers(this.server, this.sessionId);
+    const screenRecordingStopTasks = [
+      async () => {
+        if (!_lodash.default.isEmpty(this._screenRecordingProperties)) {
+          await this.stopRecordingScreen();
+        }
+      },
+      async () => {
+        if (await this.mobileIsMediaProjectionRecordingRunning()) {
+          await this.mobileStopMediaProjectionRecording();
+        }
+      },
+      async () => {
+        if (!_lodash.default.isEmpty(this._screenStreamingProps)) {
+          await this.mobileStopScreenStreaming();
+        }
+      },
+    ];
+    await _appiumAndroidDriver.androidHelpers.removeAllSessionWebSocketHandlers(
+      this.server,
+      this.sessionId
+    );
     if (this.uiautomator2) {
       try {
         await this.stopChromedriverProxies();
@@ -401,13 +560,15 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
     }
     this.jwpProxyActive = false;
     if (this.adb) {
-      await _bluebird.default.all(screenRecordingStopTasks.map(task => {
-        (async () => {
-          try {
-            await task();
-          } catch (ign) {}
-        })();
-      }));
+      await _bluebird.default.all(
+        screenRecordingStopTasks.map((task) => {
+          (async () => {
+            try {
+              await task();
+            } catch (ign) {}
+          })();
+        })
+      );
       if (this.opts.unicodeKeyboard && this.opts.resetKeyboard && this.defaultIME) {
         this.log.debug(`Resetting IME to '${this.defaultIME}'`);
         try {
@@ -420,10 +581,14 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
         this.log.info('Shutting down the adb process of instrumentation...');
         await this.adb.endAndroidCoverage();
         if (this.caps.androidCoverageEndIntent) {
-          this.log.info(`Sending intent broadcast '${this.caps.androidCoverageEndIntent}' at the end of instrumenting.`);
+          this.log.info(
+            `Sending intent broadcast '${this.caps.androidCoverageEndIntent}' at the end of instrumenting.`
+          );
           await this.adb.broadcast(this.caps.androidCoverageEndIntent);
         } else {
-          this.log.warn('No androidCoverageEndIntent is configured in caps. Possibly you cannot get coverage file.');
+          this.log.warn(
+            'No androidCoverageEndIntent is configured in caps. Possibly you cannot get coverage file.'
+          );
         }
       }
       if (this.opts.appPackage) {
@@ -435,7 +600,9 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
           }
         }
         if (this.opts.fullReset && !this.opts.skipUninstall) {
-          this.log.debug(`Capability 'fullReset' set to 'true', Uninstalling '${this.opts.appPackage}'`);
+          this.log.debug(
+            `Capability 'fullReset' set to 'true', Uninstalling '${this.opts.appPackage}'`
+          );
           try {
             await this.adb.uninstallApk(this.opts.appPackage);
           } catch (err) {
@@ -507,7 +674,10 @@ class AndroidUiautomator2Driver extends _driver.BaseDriver {
       this.jwpProxyAvoid = NO_PROXY;
     }
     if (this.opts.nativeWebScreenshot) {
-      this.jwpProxyAvoid = [...this.jwpProxyAvoid, ['GET', new RegExp('^/session/[^/]+/screenshot')]];
+      this.jwpProxyAvoid = [
+        ...this.jwpProxyAvoid,
+        ['GET', new RegExp('^/session/[^/]+/screenshot')],
+      ];
     }
     return this.jwpProxyAvoid;
   }
diff --git a/node_modules/appium-uiautomator2-driver/lib/driver.js b/node_modules/appium-uiautomator2-driver/lib/driver.js
index c5c9e77..0ccbcaf 100644
--- a/node_modules/appium-uiautomator2-driver/lib/driver.js
+++ b/node_modules/appium-uiautomator2-driver/lib/driver.js
@@ -1,23 +1,18 @@
 import _ from 'lodash';
-import { BaseDriver, DeviceSettings } from 'appium/driver';
-import {
-  UiAutomator2Server, SERVER_PACKAGE_ID, SERVER_TEST_PACKAGE_ID
-} from './uiautomator2';
-import { fs, util, mjpeg } from 'appium/support';
-import { retryInterval } from 'asyncbox';
+import {BaseDriver, DeviceSettings} from 'appium/driver';
+import {UiAutomator2Server, SERVER_PACKAGE_ID, SERVER_TEST_PACKAGE_ID} from './uiautomator2';
+import {fs, util, mjpeg} from 'appium/support';
+import {retryInterval} from 'asyncbox';
 import B from 'bluebird';
 import commands from './commands/index';
-import { DEFAULT_ADB_PORT } from 'appium-adb';
+import {DEFAULT_ADB_PORT} from 'appium-adb';
 import uiautomator2Helpers from './helpers';
-import {
-  androidHelpers, androidCommands, SETTINGS_HELPER_PKG_ID
-} from 'appium-android-driver';
+import {androidHelpers, androidCommands, SETTINGS_HELPER_PKG_ID} from 'appium-android-driver';
 import desiredCapConstraints from './desired-caps';
-import { findAPortNotInUse, checkPortStatus } from 'portscanner';
+import {findAPortNotInUse, checkPortStatus} from 'portscanner';
 import os from 'os';
 import path from 'path';
-import { APK_EXTENSION, APKS_EXTENSION } from './extensions';
-
+import {APK_EXTENSION, APKS_EXTENSION} from './extensions';
 
 const helpers = Object.assign({}, uiautomator2Helpers, androidHelpers);
 
@@ -139,13 +134,10 @@ const CHROME_NO_PROXY = [
   ['POST', new RegExp('^/session/[^/]+/se/log$')],
 ];
 
-const MEMOIZED_FUNCTIONS = [
-  'getStatusBarHeight',
-  'getDevicePixelRatio',
-];
+const MEMOIZED_FUNCTIONS = ['getStatusBarHeight', 'getDevicePixelRatio'];
 
 class AndroidUiautomator2Driver extends BaseDriver {
-  constructor (opts = {}, shouldValidateCaps = true) {
+  constructor(opts = {}, shouldValidateCaps = true) {
     // `shell` overwrites adb.shell, so remove
     delete opts.shell;
 
@@ -156,7 +148,7 @@ class AndroidUiautomator2Driver extends BaseDriver {
       'class name',
       'accessibility id',
       'css selector',
-      '-android uiautomator'
+      '-android uiautomator',
     ];
     this.desiredCapConstraints = desiredCapConstraints;
     this.uiautomator2 = null;
@@ -165,8 +157,10 @@ class AndroidUiautomator2Driver extends BaseDriver {
     this.jwpProxyAvoid = NO_PROXY;
     this.apkStrings = {}; // map of language -> strings obj
 
-    this.settings = new DeviceSettings({ignoreUnimportantViews: false, allowInvisibleElements: false},
-        this.onSettingsUpdate.bind(this));
+    this.settings = new DeviceSettings(
+      {ignoreUnimportantViews: false, allowInvisibleElements: true, enableMultiWindows: true},
+      this.onSettingsUpdate.bind(this)
+    );
     // handle webview mechanics from AndroidDriver
     this.chromedriver = null;
     this.sessionChromedrivers = {};
@@ -177,11 +171,11 @@ class AndroidUiautomator2Driver extends BaseDriver {
     }
   }
 
-  validateDesiredCaps (caps) {
+  validateDesiredCaps(caps) {
     return super.validateDesiredCaps(caps) && androidHelpers.validateDesiredCaps(caps);
   }
 
-  async createSession (...args) {
+  async createSession(...args) {
     try {
       // TODO handle otherSessionData for multiple sessions
       let [sessionId, caps] = await super.createSession(...args);
@@ -206,7 +200,7 @@ class AndroidUiautomator2Driver extends BaseDriver {
         fullReset: false,
         autoLaunch: true,
         adbPort: DEFAULT_ADB_PORT,
-        androidInstallTimeout: 90000
+        androidInstallTimeout: 90000,
       };
       _.defaults(this.opts, defaultOpts);
 
@@ -224,15 +218,20 @@ class AndroidUiautomator2Driver extends BaseDriver {
 
       if (this.opts.app) {
         // find and copy, or download and unzip an app url or path
-        this.opts.app = await this.helpers.configureApp(this.opts.app, [APK_EXTENSION, APKS_EXTENSION]);
+        this.opts.app = await this.helpers.configureApp(this.opts.app, [
+          APK_EXTENSION,
+          APKS_EXTENSION,
+        ]);
         await this.checkAppPresent();
       } else if (this.opts.appPackage) {
         // the app isn't an actual app file but rather something we want to
         // assume is on the device and just launch via the appPackage
         this.log.info(`Starting '${this.opts.appPackage}' directly on the device`);
       } else {
-        this.log.info(`Neither 'app' nor 'appPackage' was set. Starting UiAutomator2 ` +
-          'without the target application');
+        this.log.info(
+          `Neither 'app' nor 'appPackage' was set. Starting UiAutomator2 ` +
+            'without the target application'
+        );
       }
       this.opts.adbPort = this.opts.adbPort || DEFAULT_ADB_PORT;
 
@@ -250,51 +249,59 @@ class AndroidUiautomator2Driver extends BaseDriver {
     }
   }
 
-  async fillDeviceDetails () {
+  async fillDeviceDetails() {
     this.caps.pixelRatio = await this.getDevicePixelRatio();
     this.caps.statBarHeight = await this.getStatusBarHeight();
     this.caps.viewportRect = await this.getViewPortRect();
   }
 
-  get driverData () {
+  get driverData() {
     // TODO fill out resource info here
     return {};
   }
 
-  async getSession () {
+  async getSession() {
     let sessionData = await super.getSession();
     this.log.debug('Getting session details from server to mix in');
     let uia2Data = await this.uiautomator2.jwproxy.command('/', 'GET', {});
     return Object.assign({}, sessionData, uia2Data);
   }
 
-  isEmulator () {
+  isEmulator() {
     return helpers.isEmulator(this.adb, this.opts);
   }
 
-  setAvdFromCapabilities (caps) {
+  setAvdFromCapabilities(caps) {
     if (this.opts.avd) {
       this.log.info('avd name defined, ignoring device name and platform version');
     } else {
       if (!caps.deviceName) {
-        this.log.errorAndThrow('avd or deviceName should be specified when reboot option is enables');
+        this.log.errorAndThrow(
+          'avd or deviceName should be specified when reboot option is enables'
+        );
       }
       if (!caps.platformVersion) {
-        this.log.errorAndThrow('avd or platformVersion should be specified when reboot option is enabled');
+        this.log.errorAndThrow(
+          'avd or platformVersion should be specified when reboot option is enabled'
+        );
       }
       let avdDevice = caps.deviceName.replace(/[^a-zA-Z0-9_.]/g, '-');
       this.opts.avd = `${avdDevice}__${caps.platformVersion}`;
     }
   }
 
-  async allocateSystemPort () {
+  async allocateSystemPort() {
     const forwardPort = async (localPort) => {
-      this.log.debug(`Forwarding UiAutomator2 Server port ${DEVICE_PORT} to local port ${localPort}`);
+      this.log.debug(
+        `Forwarding UiAutomator2 Server port ${DEVICE_PORT} to local port ${localPort}`
+      );
       if ((await checkPortStatus(localPort, LOCALHOST_IP4)) === 'open') {
-        this.log.errorAndThrow(`UiAutomator2 Server cannot start because the local port #${localPort} is busy. ` +
-          `Make sure the port you provide via 'systemPort' capability is not occupied. ` +
-          `This situation might often be a result of an inaccurate sessions management, e.g. ` +
-          `old automation sessions on the same device must always be closed before starting new ones.`);
+        this.log.errorAndThrow(
+          `UiAutomator2 Server cannot start because the local port #${localPort} is busy. ` +
+            `Make sure the port you provide via 'systemPort' capability is not occupied. ` +
+            `This situation might often be a result of an inaccurate sessions management, e.g. ` +
+            `old automation sessions on the same device must always be closed before starting new ones.`
+        );
       }
       await this.adb.forwardPort(localPort, DEVICE_PORT);
     };
@@ -311,15 +318,16 @@ class AndroidUiautomator2Driver extends BaseDriver {
       } catch (e) {
         this.log.errorAndThrow(
           `Cannot find any free port in range ${startPort}..${endPort}}. ` +
-          `Please set the available port number by providing the systemPort capability or ` +
-          `double check the processes that are locking ports within this range and terminate ` +
-          `these which are not needed anymore`);
+            `Please set the available port number by providing the systemPort capability or ` +
+            `double check the processes that are locking ports within this range and terminate ` +
+            `these which are not needed anymore`
+        );
       }
       await forwardPort(this.opts.systemPort);
     });
   }
 
-  async releaseSystemPort () {
+  async releaseSystemPort() {
     if (!this.opts.systemPort || !this.adb) {
       return;
     }
@@ -327,23 +335,25 @@ class AndroidUiautomator2Driver extends BaseDriver {
     if (this._hasSystemPortInCaps) {
       await this.adb.removePortForward(this.opts.systemPort);
     } else {
-      await DEVICE_PORT_ALLOCATION_GUARD(async () => await this.adb.removePortForward(this.opts.systemPort));
+      await DEVICE_PORT_ALLOCATION_GUARD(
+        async () => await this.adb.removePortForward(this.opts.systemPort)
+      );
     }
   }
 
-  async allocateMjpegServerPort () {
+  async allocateMjpegServerPort() {
     if (this.opts.mjpegServerPort) {
       await this.adb.forwardPort(this.opts.mjpegServerPort, MJPEG_SERVER_DEVICE_PORT);
     }
   }
 
-  async releaseMjpegServerPort () {
+  async releaseMjpegServerPort() {
     if (this.opts.mjpegServerPort) {
       await this.adb.removePortForward(this.opts.mjpegServerPort);
     }
   }
 
-  async startUiAutomator2Session () {
+  async startUiAutomator2Session() {
     // get device udid for this session
     let {udid, emPort} = await helpers.getDeviceInfoFromCaps(this.opts);
     this.opts.udid = udid;
@@ -356,11 +366,14 @@ class AndroidUiautomator2Driver extends BaseDriver {
     const apiLevel = await this.adb.getApiLevel();
 
     if (apiLevel < 21) {
-      this.log.errorAndThrow('UIAutomator2 is only supported since Android 5.0 (Lollipop). ' +
-        'You could still use other supported backends in order to automate older Android versions.');
+      this.log.errorAndThrow(
+        'UIAutomator2 is only supported since Android 5.0 (Lollipop). ' +
+          'You could still use other supported backends in order to automate older Android versions.'
+      );
     }
 
-    if (apiLevel >= 28) { // Android P
+    if (apiLevel >= 28) {
+      // Android P
       this.log.info('Relaxing hidden api policy');
       await this.adb.setHiddenApiPolicy('1', !!this.opts.ignoreHiddenApiPolicyError);
     }
@@ -368,7 +381,9 @@ class AndroidUiautomator2Driver extends BaseDriver {
     // check if we have to enable/disable gps before running the application
     if (util.hasValue(this.opts.gpsEnabled)) {
       if (this.isEmulator()) {
-        this.log.info(`Trying to ${this.opts.gpsEnabled ? 'enable' : 'disable'} gps location provider`);
+        this.log.info(
+          `Trying to ${this.opts.gpsEnabled ? 'enable' : 'disable'} gps location provider`
+        );
         await this.adb.toggleGPSLocationProvider(this.opts.gpsEnabled);
       } else {
         this.log.warn(`Sorry! 'gpsEnabled' capability is only available for emulators`);
@@ -400,7 +415,8 @@ class AndroidUiautomator2Driver extends BaseDriver {
     await this.initUiAutomator2Server();
 
     // Should be after installing io.appium.settings in helpers.initDevice
-    if (this.opts.disableWindowAnimation && (await this.adb.getApiLevel() < 26)) { // API level 26 is Android 8.0.
+    if (this.opts.disableWindowAnimation && (await this.adb.getApiLevel()) < 26) {
+      // API level 26 is Android 8.0.
       // Granting android.permission.SET_ANIMATION_SCALE is necessary to handle animations under API level 26
       // Read https://github.com/appium/appium/pull/11640#issuecomment-438260477
       // `--no-window-animation` works over Android 8 to disable all of animations
@@ -435,7 +451,8 @@ class AndroidUiautomator2Driver extends BaseDriver {
       this.log.debug(`'skipUnlock' capability set, so skipping device unlock`);
     }
 
-    if (this.isChromeSession) { // start a chromedriver session
+    if (this.isChromeSession) {
+      // start a chromedriver session
       await this.startChromeSession(this);
     } else if (this.opts.autoLaunch && this.opts.appPackage) {
       await this.ensureAppStarts();
@@ -461,15 +478,9 @@ class AndroidUiautomator2Driver extends BaseDriver {
     this.jwpProxyActive = true;
   }
 
-  async addDeviceInfoToCaps () {
-    const {
-      apiVersion,
-      platformVersion,
-      manufacturer,
-      model,
-      realDisplaySize,
-      displayDensity,
-    } = await this.mobileGetDeviceInfo();
+  async addDeviceInfoToCaps() {
+    const {apiVersion, platformVersion, manufacturer, model, realDisplaySize, displayDensity} =
+      await this.mobileGetDeviceInfo();
     this.caps.deviceApiLevel = parseInt(apiVersion, 10);
     this.caps.platformVersion = platformVersion;
     this.caps.deviceScreenSize = realDisplaySize;
@@ -478,7 +489,7 @@ class AndroidUiautomator2Driver extends BaseDriver {
     this.caps.deviceManufacturer = manufacturer;
   }
 
-  async initUiAutomator2Server () {
+  async initUiAutomator2Server() {
     // broken out for readability
     const uiautomator2Opts = {
       host: this.opts.remoteAdbHost || this.opts.host || LOCALHOST_IP4,
@@ -505,16 +516,20 @@ class AndroidUiautomator2Driver extends BaseDriver {
       await this.uiautomator2.installServerApk(this.opts.uiautomator2ServerInstallTimeout);
       try {
         await this.adb.addToDeviceIdleWhitelist(
-          SETTINGS_HELPER_PKG_ID, SERVER_PACKAGE_ID, SERVER_TEST_PACKAGE_ID,
+          SETTINGS_HELPER_PKG_ID,
+          SERVER_PACKAGE_ID,
+          SERVER_TEST_PACKAGE_ID
         );
       } catch (e) {
-        this.log.warn(`Cannot add server packages to the Doze whitelist. Original error: ` +
-          (e.stderr || e.message));
+        this.log.warn(
+          `Cannot add server packages to the Doze whitelist. Original error: ` +
+            (e.stderr || e.message)
+        );
       }
     }
   }
 
-  async initAUT () {
+  async initAUT() {
     // Uninstall any uninstallOtherPackages which were specified in caps
     if (this.opts.uninstallOtherPackages) {
       await helpers.uninstallOtherPackages(
@@ -532,17 +547,23 @@ class AndroidUiautomator2Driver extends BaseDriver {
       } catch (e) {
         this.log.errorAndThrow(`Could not parse "otherApps" capability: ${e.message}`);
       }
-      otherApps = await B.all(otherApps
-        .map((app) => this.helpers.configureApp(app, [APK_EXTENSION, APKS_EXTENSION])));
+      otherApps = await B.all(
+        otherApps.map((app) => this.helpers.configureApp(app, [APK_EXTENSION, APKS_EXTENSION]))
+      );
       await helpers.installOtherApks(otherApps, this.adb, this.opts);
     }
 
     if (this.opts.app) {
-      if (this.opts.noReset && !(await this.adb.isAppInstalled(this.opts.appPackage))
-          || !this.opts.noReset) {
-        if (!this.opts.noSign && !await this.adb.checkApkCert(this.opts.app, this.opts.appPackage, {
-          requireDefaultCert: false,
-        })) {
+      if (
+        (this.opts.noReset && !(await this.adb.isAppInstalled(this.opts.appPackage))) ||
+        !this.opts.noReset
+      ) {
+        if (
+          !this.opts.noSign &&
+          !(await this.adb.checkApkCert(this.opts.app, this.opts.appPackage, {
+            requireDefaultCert: false,
+          }))
+        ) {
           await helpers.signApp(this.adb, this.opts.app);
         }
         if (!this.opts.skipUninstall) {
@@ -550,11 +571,15 @@ class AndroidUiautomator2Driver extends BaseDriver {
         }
         await helpers.installApk(this.adb, this.opts);
       } else {
-        this.log.debug('noReset has been requested and the app is already installed. Doing nothing');
+        this.log.debug(
+          'noReset has been requested and the app is already installed. Doing nothing'
+        );
       }
     } else {
       if (this.opts.fullReset) {
-        this.log.errorAndThrow('Full reset requires an app capability, use fastReset if app is not provided');
+        this.log.errorAndThrow(
+          'Full reset requires an app capability, use fastReset if app is not provided'
+        );
       }
       this.log.debug('No app capability. Assuming it is already on the device');
       if (this.opts.fastReset && this.opts.appPackage) {
@@ -563,24 +588,33 @@ class AndroidUiautomator2Driver extends BaseDriver {
     }
   }
 
-  async ensureAppStarts () {
+  async ensureAppStarts() {
     // make sure we have an activity and package to wait for
     const appWaitPackage = this.opts.appWaitPackage || this.opts.appPackage;
     const appWaitActivity = this.opts.appWaitActivity || this.opts.appActivity;
 
-    this.log.info(`Starting '${this.opts.appPackage}/${this.opts.appActivity} ` +
-      `and waiting for '${appWaitPackage}/${appWaitActivity}'`);
+    this.log.info(
+      `Starting '${this.opts.appPackage}/${this.opts.appActivity} ` +
+        `and waiting for '${appWaitPackage}/${appWaitActivity}'`
+    );
 
     if (this.caps.androidCoverage) {
-      this.log.info(`androidCoverage is configured. ` +
-        ` Starting instrumentation of '${this.caps.androidCoverage}'...`);
+      this.log.info(
+        `androidCoverage is configured. ` +
+          ` Starting instrumentation of '${this.caps.androidCoverage}'...`
+      );
       await this.adb.androidCoverage(this.caps.androidCoverage, appWaitPackage, appWaitActivity);
       return;
     }
-    if (this.opts.noReset && !this.opts.forceAppLaunch
-        && await this.adb.processExists(this.opts.appPackage)) {
-      this.log.info(`'${this.opts.appPackage}' is already running and noReset is enabled. ` +
-        `Set forceAppLaunch capability to true if the app must be forcefully restarted on session startup.`);
+    if (
+      this.opts.noReset &&
+      !this.opts.forceAppLaunch &&
+      (await this.adb.processExists(this.opts.appPackage))
+    ) {
+      this.log.info(
+        `'${this.opts.appPackage}' is already running and noReset is enabled. ` +
+          `Set forceAppLaunch capability to true if the app must be forcefully restarted on session startup.`
+      );
       return;
     }
     await this.adb.startApp({
@@ -600,22 +634,26 @@ class AndroidUiautomator2Driver extends BaseDriver {
     });
   }
 
-  async deleteSession () {
+  async deleteSession() {
     this.log.debug('Deleting UiAutomator2 session');
 
-    const screenRecordingStopTasks = [async () => {
-      if (!_.isEmpty(this._screenRecordingProperties)) {
-        await this.stopRecordingScreen();
-      }
-    }, async () => {
-      if (await this.mobileIsMediaProjectionRecordingRunning()) {
-        await this.mobileStopMediaProjectionRecording();
-      }
-    }, async () => {
-      if (!_.isEmpty(this._screenStreamingProps)) {
-        await this.mobileStopScreenStreaming();
-      }
-    }];
+    const screenRecordingStopTasks = [
+      async () => {
+        if (!_.isEmpty(this._screenRecordingProperties)) {
+          await this.stopRecordingScreen();
+        }
+      },
+      async () => {
+        if (await this.mobileIsMediaProjectionRecordingRunning()) {
+          await this.mobileStopMediaProjectionRecording();
+        }
+      },
+      async () => {
+        if (!_.isEmpty(this._screenStreamingProps)) {
+          await this.mobileStopScreenStreaming();
+        }
+      },
+    ];
 
     await androidHelpers.removeAllSessionWebSocketHandlers(this.server, this.sessionId);
 
@@ -637,13 +675,15 @@ class AndroidUiautomator2Driver extends BaseDriver {
     this.jwpProxyActive = false;
 
     if (this.adb) {
-      await B.all(screenRecordingStopTasks.map((task) => {
-        (async () => {
-          try {
-            await task();
-          } catch (ign) {}
-        })();
-      }));
+      await B.all(
+        screenRecordingStopTasks.map((task) => {
+          (async () => {
+            try {
+              await task();
+            } catch (ign) {}
+          })();
+        })
+      );
 
       if (this.opts.unicodeKeyboard && this.opts.resetKeyboard && this.defaultIME) {
         this.log.debug(`Resetting IME to '${this.defaultIME}'`);
@@ -658,16 +698,18 @@ class AndroidUiautomator2Driver extends BaseDriver {
         await this.adb.endAndroidCoverage();
         // Use this broadcast intent to notify it's time to dump coverage to file
         if (this.caps.androidCoverageEndIntent) {
-          this.log.info(`Sending intent broadcast '${this.caps.androidCoverageEndIntent}' at the end of instrumenting.`);
+          this.log.info(
+            `Sending intent broadcast '${this.caps.androidCoverageEndIntent}' at the end of instrumenting.`
+          );
           await this.adb.broadcast(this.caps.androidCoverageEndIntent);
         } else {
-          this.log.warn('No androidCoverageEndIntent is configured in caps. Possibly you cannot get coverage file.');
+          this.log.warn(
+            'No androidCoverageEndIntent is configured in caps. Possibly you cannot get coverage file.'
+          );
         }
       }
       if (this.opts.appPackage) {
-        if (!this.isChromeSession
-            && !this.opts.dontStopAppOnReset
-            && !this.opts.noReset) {
+        if (!this.isChromeSession && !this.opts.dontStopAppOnReset && !this.opts.noReset) {
           try {
             await this.adb.forceStop(this.opts.appPackage);
           } catch (err) {
@@ -675,7 +717,9 @@ class AndroidUiautomator2Driver extends BaseDriver {
           }
         }
         if (this.opts.fullReset && !this.opts.skipUninstall) {
-          this.log.debug(`Capability 'fullReset' set to 'true', Uninstalling '${this.opts.appPackage}'`);
+          this.log.debug(
+            `Capability 'fullReset' set to 'true', Uninstalling '${this.opts.appPackage}'`
+          );
           try {
             await this.adb.uninstallApk(this.opts.appPackage);
           } catch (err) {
@@ -704,7 +748,8 @@ class AndroidUiautomator2Driver extends BaseDriver {
         // and before even port forward.
       }
 
-      if (await this.adb.getApiLevel() >= 28) { // Android P
+      if ((await this.adb.getApiLevel()) >= 28) {
+        // Android P
         this.log.info('Restoring hidden api policy to the device default configuration');
         await this.adb.setDefaultHiddenApiPolicy(!!this.opts.ignoreHiddenApiPolicyError);
       }
@@ -726,14 +771,14 @@ class AndroidUiautomator2Driver extends BaseDriver {
     await super.deleteSession();
   }
 
-  async checkAppPresent () {
+  async checkAppPresent() {
     this.log.debug('Checking whether app is actually present');
     if (!(await fs.exists(this.opts.app))) {
       this.log.errorAndThrow(`Could not find app apk at '${this.opts.app}'`);
     }
   }
 
-  async onSettingsUpdate () {
+  async onSettingsUpdate() {
     // intentionally do nothing here, since commands.updateSettings proxies
     // settings to the uiauto2 server already
   }
@@ -741,28 +786,28 @@ class AndroidUiautomator2Driver extends BaseDriver {
   // Need to override android-driver's version of this since we don't actually
   // have a bootstrap; instead we just restart adb and re-forward the UiAutomator2
   // port
-  async wrapBootstrapDisconnect (wrapped) {
+  async wrapBootstrapDisconnect(wrapped) {
     await wrapped();
     await this.adb.restart();
     await this.allocateSystemPort();
     await this.allocateMjpegServerPort();
   }
 
-  proxyActive (sessionId) {
+  proxyActive(sessionId) {
     super.proxyActive(sessionId);
 
     // we always have an active proxy to the UiAutomator2 server
     return true;
   }
 
-  canProxy (sessionId) {
+  canProxy(sessionId) {
     super.canProxy(sessionId);
 
     // we can always proxy to the uiautomator2 server
     return true;
   }
 
-  getProxyAvoidList (sessionId) {
+  getProxyAvoidList(sessionId) {
     super.getProxyAvoidList(sessionId);
     // we are maintaining two sets of NO_PROXY lists, one for chromedriver(CHROME_NO_PROXY)
     // and one for uiautomator2(NO_PROXY), based on current context will return related NO_PROXY list
@@ -773,13 +818,16 @@ class AndroidUiautomator2Driver extends BaseDriver {
       this.jwpProxyAvoid = NO_PROXY;
     }
     if (this.opts.nativeWebScreenshot) {
-      this.jwpProxyAvoid = [...this.jwpProxyAvoid, ['GET', new RegExp('^/session/[^/]+/screenshot')]];
+      this.jwpProxyAvoid = [
+        ...this.jwpProxyAvoid,
+        ['GET', new RegExp('^/session/[^/]+/screenshot')],
+      ];
     }
 
     return this.jwpProxyAvoid;
   }
 
-  get isChromeSession () {
+  get isChromeSession() {
     return helpers.isChromeBrowser(this.opts.browserName);
   }
 }
@@ -794,5 +842,5 @@ for (let [cmd, fn] of _.toPairs(commands)) {
   AndroidUiautomator2Driver.prototype[cmd] = fn;
 }
 
-export { AndroidUiautomator2Driver };
+export {AndroidUiautomator2Driver};
 export default AndroidUiautomator2Driver;
